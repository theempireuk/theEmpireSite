{"ast":null,"code":"import { Material } from './Material.js';\nimport { cloneUniforms } from '../renderers/shaders/UniformsUtils.js';\nimport default_vertex from '../renderers/shaders/ShaderChunk/default_vertex.glsl.js';\nimport default_fragment from '../renderers/shaders/ShaderChunk/default_fragment.glsl.js';\n/**\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction ShaderMaterial(parameters) {\n  Material.call(this);\n  this.type = 'ShaderMaterial';\n  this.defines = {};\n  this.uniforms = {};\n  this.vertexShader = default_vertex;\n  this.fragmentShader = default_fragment;\n  this.linewidth = 1;\n  this.wireframe = false;\n  this.wireframeLinewidth = 1;\n  this.fog = false; // set to use scene fog\n\n  this.lights = false; // set to use scene lights\n\n  this.clipping = false; // set to use user-defined clipping planes\n\n  this.skinning = false; // set to use skinning attribute streams\n\n  this.morphTargets = false; // set to use morph targets\n\n  this.morphNormals = false; // set to use morph normals\n\n  this.extensions = {\n    derivatives: false,\n    // set to use derivatives\n    fragDepth: false,\n    // set to use fragment depth values\n    drawBuffers: false,\n    // set to use draw buffers\n    shaderTextureLOD: false // set to use shader texture LOD\n\n  }; // When rendered geometry doesn't include these attributes but the material does,\n  // use these default values in WebGL. This avoids errors when buffer data is missing.\n\n  this.defaultAttributeValues = {\n    'color': [1, 1, 1],\n    'uv': [0, 0],\n    'uv2': [0, 0]\n  };\n  this.index0AttributeName = undefined;\n  this.uniformsNeedUpdate = false;\n  this.glslVersion = null;\n\n  if (parameters !== undefined) {\n    if (parameters.attributes !== undefined) {\n      console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\n    }\n\n    this.setValues(parameters);\n  }\n}\n\nShaderMaterial.prototype = Object.create(Material.prototype);\nShaderMaterial.prototype.constructor = ShaderMaterial;\nShaderMaterial.prototype.isShaderMaterial = true;\n\nShaderMaterial.prototype.copy = function (source) {\n  Material.prototype.copy.call(this, source);\n  this.fragmentShader = source.fragmentShader;\n  this.vertexShader = source.vertexShader;\n  this.uniforms = cloneUniforms(source.uniforms);\n  this.defines = Object.assign({}, source.defines);\n  this.wireframe = source.wireframe;\n  this.wireframeLinewidth = source.wireframeLinewidth;\n  this.lights = source.lights;\n  this.clipping = source.clipping;\n  this.skinning = source.skinning;\n  this.morphTargets = source.morphTargets;\n  this.morphNormals = source.morphNormals;\n  this.extensions = Object.assign({}, source.extensions);\n  this.glslVersion = source.glslVersion;\n  return this;\n};\n\nShaderMaterial.prototype.toJSON = function (meta) {\n  var data = Material.prototype.toJSON.call(this, meta);\n  data.glslVersion = this.glslVersion;\n  data.uniforms = {};\n\n  for (var name in this.uniforms) {\n    var uniform = this.uniforms[name];\n    var value = uniform.value;\n\n    if (value && value.isTexture) {\n      data.uniforms[name] = {\n        type: 't',\n        value: value.toJSON(meta).uuid\n      };\n    } else if (value && value.isColor) {\n      data.uniforms[name] = {\n        type: 'c',\n        value: value.getHex()\n      };\n    } else if (value && value.isVector2) {\n      data.uniforms[name] = {\n        type: 'v2',\n        value: value.toArray()\n      };\n    } else if (value && value.isVector3) {\n      data.uniforms[name] = {\n        type: 'v3',\n        value: value.toArray()\n      };\n    } else if (value && value.isVector4) {\n      data.uniforms[name] = {\n        type: 'v4',\n        value: value.toArray()\n      };\n    } else if (value && value.isMatrix3) {\n      data.uniforms[name] = {\n        type: 'm3',\n        value: value.toArray()\n      };\n    } else if (value && value.isMatrix4) {\n      data.uniforms[name] = {\n        type: 'm4',\n        value: value.toArray()\n      };\n    } else {\n      data.uniforms[name] = {\n        value: value\n      }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n    }\n  }\n\n  if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n  data.vertexShader = this.vertexShader;\n  data.fragmentShader = this.fragmentShader;\n  var extensions = {};\n\n  for (var key in this.extensions) {\n    if (this.extensions[key] === true) extensions[key] = true;\n  }\n\n  if (Object.keys(extensions).length > 0) data.extensions = extensions;\n  return data;\n};\n\nexport { ShaderMaterial };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/materials/ShaderMaterial.js"],"names":["Material","cloneUniforms","default_vertex","default_fragment","ShaderMaterial","parameters","call","type","defines","uniforms","vertexShader","fragmentShader","linewidth","wireframe","wireframeLinewidth","fog","lights","clipping","skinning","morphTargets","morphNormals","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","undefined","uniformsNeedUpdate","glslVersion","attributes","console","error","setValues","prototype","Object","create","constructor","isShaderMaterial","copy","source","assign","toJSON","meta","data","name","uniform","value","isTexture","uuid","isColor","getHex","isVector2","toArray","isVector3","isVector4","isMatrix3","isMatrix4","keys","length","key"],"mappings":"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","sourcesContent":["import { Material } from './Material.js';\nimport { cloneUniforms } from '../renderers/shaders/UniformsUtils.js';\n\nimport default_vertex from '../renderers/shaders/ShaderChunk/default_vertex.glsl.js';\nimport default_fragment from '../renderers/shaders/ShaderChunk/default_fragment.glsl.js';\n\n/**\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction ShaderMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = default_vertex;\n\tthis.fragmentShader = default_fragment;\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\tthis.uniformsNeedUpdate = false;\n\n\tthis.glslVersion = null;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nShaderMaterial.prototype = Object.create( Material.prototype );\nShaderMaterial.prototype.constructor = ShaderMaterial;\n\nShaderMaterial.prototype.isShaderMaterial = true;\n\nShaderMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = cloneUniforms( source.uniforms );\n\n\tthis.defines = Object.assign( {}, source.defines );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = Object.assign( {}, source.extensions );\n\n\tthis.glslVersion = source.glslVersion;\n\n\treturn this;\n\n};\n\nShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tconst data = Material.prototype.toJSON.call( this, meta );\n\n\tdata.glslVersion = this.glslVersion;\n\tdata.uniforms = {};\n\n\tfor ( const name in this.uniforms ) {\n\n\t\tconst uniform = this.uniforms[ name ];\n\t\tconst value = uniform.value;\n\n\t\tif ( value && value.isTexture ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t};\n\n\t\t} else if ( value && value.isColor ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'c',\n\t\t\t\tvalue: value.getHex()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v2',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v3',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v4',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'm3',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'm4',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\tvalue: value\n\t\t\t};\n\n\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t}\n\n\t}\n\n\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\tconst extensions = {};\n\n\tfor ( const key in this.extensions ) {\n\n\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t}\n\n\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\treturn data;\n\n};\n\n\nexport { ShaderMaterial };\n"]},"metadata":{},"sourceType":"module"}