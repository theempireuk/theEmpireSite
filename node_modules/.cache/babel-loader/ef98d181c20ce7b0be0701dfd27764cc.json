{"ast":null,"code":"import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nfunction AnimationMixer(root) {\n  this._root = root;\n\n  this._initMemoryManager();\n\n  this._accuIndex = 0;\n  this.time = 0;\n  this.timeScale = 1.0;\n}\n\nAnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n  constructor: AnimationMixer,\n  _bindAction: function _bindAction(action, prototypeAction) {\n    var root = action._localRoot || this._root,\n        tracks = action._clip.tracks,\n        nTracks = tracks.length,\n        bindings = action._propertyBindings,\n        interpolants = action._interpolants,\n        rootUuid = root.uuid,\n        bindingsByRoot = this._bindingsByRootAndName;\n    var bindingsByName = bindingsByRoot[rootUuid];\n\n    if (bindingsByName === undefined) {\n      bindingsByName = {};\n      bindingsByRoot[rootUuid] = bindingsByName;\n    }\n\n    for (var i = 0; i !== nTracks; ++i) {\n      var track = tracks[i],\n          trackName = track.name;\n      var binding = bindingsByName[trackName];\n\n      if (binding !== undefined) {\n        bindings[i] = binding;\n      } else {\n        binding = bindings[i];\n\n        if (binding !== undefined) {\n          // existing binding, make sure the cache knows\n          if (binding._cacheIndex === null) {\n            ++binding.referenceCount;\n\n            this._addInactiveBinding(binding, rootUuid, trackName);\n          }\n\n          continue;\n        }\n\n        var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n        ++binding.referenceCount;\n\n        this._addInactiveBinding(binding, rootUuid, trackName);\n\n        bindings[i] = binding;\n      }\n\n      interpolants[i].resultBuffer = binding.buffer;\n    }\n  },\n  _activateAction: function _activateAction(action) {\n    if (!this._isActiveAction(action)) {\n      if (action._cacheIndex === null) {\n        // this action has been forgotten by the cache, but the user\n        // appears to be still using it -> rebind\n        var rootUuid = (action._localRoot || this._root).uuid,\n            clipUuid = action._clip.uuid,\n            actionsForClip = this._actionsByClip[clipUuid];\n\n        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n\n        this._addInactiveAction(action, clipUuid, rootUuid);\n      }\n\n      var bindings = action._propertyBindings; // increment reference counts / sort out state\n\n      for (var i = 0, n = bindings.length; i !== n; ++i) {\n        var binding = bindings[i];\n\n        if (binding.useCount++ === 0) {\n          this._lendBinding(binding);\n\n          binding.saveOriginalState();\n        }\n      }\n\n      this._lendAction(action);\n    }\n  },\n  _deactivateAction: function _deactivateAction(action) {\n    if (this._isActiveAction(action)) {\n      var bindings = action._propertyBindings; // decrement reference counts / sort out state\n\n      for (var i = 0, n = bindings.length; i !== n; ++i) {\n        var binding = bindings[i];\n\n        if (--binding.useCount === 0) {\n          binding.restoreOriginalState();\n\n          this._takeBackBinding(binding);\n        }\n      }\n\n      this._takeBackAction(action);\n    }\n  },\n  // Memory manager\n  _initMemoryManager: function _initMemoryManager() {\n    this._actions = []; // 'nActiveActions' followed by inactive ones\n\n    this._nActiveActions = 0;\n    this._actionsByClip = {}; // inside:\n    // {\n    // \tknownActions: Array< AnimationAction > - used as prototypes\n    // \tactionByRoot: AnimationAction - lookup\n    // }\n\n    this._bindings = []; // 'nActiveBindings' followed by inactive ones\n\n    this._nActiveBindings = 0;\n    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n    this._controlInterpolants = []; // same game as above\n\n    this._nActiveControlInterpolants = 0;\n    var scope = this;\n    this.stats = {\n      actions: {\n        get total() {\n          return scope._actions.length;\n        },\n\n        get inUse() {\n          return scope._nActiveActions;\n        }\n\n      },\n      bindings: {\n        get total() {\n          return scope._bindings.length;\n        },\n\n        get inUse() {\n          return scope._nActiveBindings;\n        }\n\n      },\n      controlInterpolants: {\n        get total() {\n          return scope._controlInterpolants.length;\n        },\n\n        get inUse() {\n          return scope._nActiveControlInterpolants;\n        }\n\n      }\n    };\n  },\n  // Memory management for AnimationAction objects\n  _isActiveAction: function _isActiveAction(action) {\n    var index = action._cacheIndex;\n    return index !== null && index < this._nActiveActions;\n  },\n  _addInactiveAction: function _addInactiveAction(action, clipUuid, rootUuid) {\n    var actions = this._actions,\n        actionsByClip = this._actionsByClip;\n    var actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip === undefined) {\n      actionsForClip = {\n        knownActions: [action],\n        actionByRoot: {}\n      };\n      action._byClipCacheIndex = 0;\n      actionsByClip[clipUuid] = actionsForClip;\n    } else {\n      var knownActions = actionsForClip.knownActions;\n      action._byClipCacheIndex = knownActions.length;\n      knownActions.push(action);\n    }\n\n    action._cacheIndex = actions.length;\n    actions.push(action);\n    actionsForClip.actionByRoot[rootUuid] = action;\n  },\n  _removeInactiveAction: function _removeInactiveAction(action) {\n    var actions = this._actions,\n        lastInactiveAction = actions[actions.length - 1],\n        cacheIndex = action._cacheIndex;\n    lastInactiveAction._cacheIndex = cacheIndex;\n    actions[cacheIndex] = lastInactiveAction;\n    actions.pop();\n    action._cacheIndex = null;\n    var clipUuid = action._clip.uuid,\n        actionsByClip = this._actionsByClip,\n        actionsForClip = actionsByClip[clipUuid],\n        knownActionsForClip = actionsForClip.knownActions,\n        lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n        byClipCacheIndex = action._byClipCacheIndex;\n    lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n    knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n    knownActionsForClip.pop();\n    action._byClipCacheIndex = null;\n    var actionByRoot = actionsForClip.actionByRoot,\n        rootUuid = (action._localRoot || this._root).uuid;\n    delete actionByRoot[rootUuid];\n\n    if (knownActionsForClip.length === 0) {\n      delete actionsByClip[clipUuid];\n    }\n\n    this._removeInactiveBindingsForAction(action);\n  },\n  _removeInactiveBindingsForAction: function _removeInactiveBindingsForAction(action) {\n    var bindings = action._propertyBindings;\n\n    for (var i = 0, n = bindings.length; i !== n; ++i) {\n      var binding = bindings[i];\n\n      if (--binding.referenceCount === 0) {\n        this._removeInactiveBinding(binding);\n      }\n    }\n  },\n  _lendAction: function _lendAction(action) {\n    // [ active actions |  inactive actions  ]\n    // [  active actions >| inactive actions ]\n    //                 s        a\n    //                  <-swap->\n    //                 a        s\n    var actions = this._actions,\n        prevIndex = action._cacheIndex,\n        lastActiveIndex = this._nActiveActions++,\n        firstInactiveAction = actions[lastActiveIndex];\n    action._cacheIndex = lastActiveIndex;\n    actions[lastActiveIndex] = action;\n    firstInactiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = firstInactiveAction;\n  },\n  _takeBackAction: function _takeBackAction(action) {\n    // [  active actions  | inactive actions ]\n    // [ active actions |< inactive actions  ]\n    //        a        s\n    //         <-swap->\n    //        s        a\n    var actions = this._actions,\n        prevIndex = action._cacheIndex,\n        firstInactiveIndex = --this._nActiveActions,\n        lastActiveAction = actions[firstInactiveIndex];\n    action._cacheIndex = firstInactiveIndex;\n    actions[firstInactiveIndex] = action;\n    lastActiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = lastActiveAction;\n  },\n  // Memory management for PropertyMixer objects\n  _addInactiveBinding: function _addInactiveBinding(binding, rootUuid, trackName) {\n    var bindingsByRoot = this._bindingsByRootAndName,\n        bindings = this._bindings;\n    var bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName === undefined) {\n      bindingByName = {};\n      bindingsByRoot[rootUuid] = bindingByName;\n    }\n\n    bindingByName[trackName] = binding;\n    binding._cacheIndex = bindings.length;\n    bindings.push(binding);\n  },\n  _removeInactiveBinding: function _removeInactiveBinding(binding) {\n    var bindings = this._bindings,\n        propBinding = binding.binding,\n        rootUuid = propBinding.rootNode.uuid,\n        trackName = propBinding.path,\n        bindingsByRoot = this._bindingsByRootAndName,\n        bindingByName = bindingsByRoot[rootUuid],\n        lastInactiveBinding = bindings[bindings.length - 1],\n        cacheIndex = binding._cacheIndex;\n    lastInactiveBinding._cacheIndex = cacheIndex;\n    bindings[cacheIndex] = lastInactiveBinding;\n    bindings.pop();\n    delete bindingByName[trackName];\n\n    if (Object.keys(bindingByName).length === 0) {\n      delete bindingsByRoot[rootUuid];\n    }\n  },\n  _lendBinding: function _lendBinding(binding) {\n    var bindings = this._bindings,\n        prevIndex = binding._cacheIndex,\n        lastActiveIndex = this._nActiveBindings++,\n        firstInactiveBinding = bindings[lastActiveIndex];\n    binding._cacheIndex = lastActiveIndex;\n    bindings[lastActiveIndex] = binding;\n    firstInactiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = firstInactiveBinding;\n  },\n  _takeBackBinding: function _takeBackBinding(binding) {\n    var bindings = this._bindings,\n        prevIndex = binding._cacheIndex,\n        firstInactiveIndex = --this._nActiveBindings,\n        lastActiveBinding = bindings[firstInactiveIndex];\n    binding._cacheIndex = firstInactiveIndex;\n    bindings[firstInactiveIndex] = binding;\n    lastActiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = lastActiveBinding;\n  },\n  // Memory management of Interpolants for weight and time scale\n  _lendControlInterpolant: function _lendControlInterpolant() {\n    var interpolants = this._controlInterpolants,\n        lastActiveIndex = this._nActiveControlInterpolants++;\n    var interpolant = interpolants[lastActiveIndex];\n\n    if (interpolant === undefined) {\n      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);\n      interpolant.__cacheIndex = lastActiveIndex;\n      interpolants[lastActiveIndex] = interpolant;\n    }\n\n    return interpolant;\n  },\n  _takeBackControlInterpolant: function _takeBackControlInterpolant(interpolant) {\n    var interpolants = this._controlInterpolants,\n        prevIndex = interpolant.__cacheIndex,\n        firstInactiveIndex = --this._nActiveControlInterpolants,\n        lastActiveInterpolant = interpolants[firstInactiveIndex];\n    interpolant.__cacheIndex = firstInactiveIndex;\n    interpolants[firstInactiveIndex] = interpolant;\n    lastActiveInterpolant.__cacheIndex = prevIndex;\n    interpolants[prevIndex] = lastActiveInterpolant;\n  },\n  _controlInterpolantsResultBuffer: new Float32Array(1),\n  // return an action for a clip optionally using a custom root target\n  // object (this method allocates a lot of dynamic memory in case a\n  // previously unknown clip/root combination is specified)\n  clipAction: function clipAction(clip, optionalRoot, blendMode) {\n    var root = optionalRoot || this._root,\n        rootUuid = root.uuid;\n    var clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;\n    var clipUuid = clipObject !== null ? clipObject.uuid : clip;\n    var actionsForClip = this._actionsByClip[clipUuid];\n    var prototypeAction = null;\n\n    if (blendMode === undefined) {\n      if (clipObject !== null) {\n        blendMode = clipObject.blendMode;\n      } else {\n        blendMode = NormalAnimationBlendMode;\n      }\n    }\n\n    if (actionsForClip !== undefined) {\n      var existingAction = actionsForClip.actionByRoot[rootUuid];\n\n      if (existingAction !== undefined && existingAction.blendMode === blendMode) {\n        return existingAction;\n      } // we know the clip, so we don't have to parse all\n      // the bindings again but can just copy\n\n\n      prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action\n\n      if (clipObject === null) clipObject = prototypeAction._clip;\n    } // clip must be known when specified via string\n\n\n    if (clipObject === null) return null; // allocate all resources required to run it\n\n    var newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n\n    this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager\n\n\n    this._addInactiveAction(newAction, clipUuid, rootUuid);\n\n    return newAction;\n  },\n  // get an existing action\n  existingAction: function existingAction(clip, optionalRoot) {\n    var root = optionalRoot || this._root,\n        rootUuid = root.uuid,\n        clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n        clipUuid = clipObject ? clipObject.uuid : clip,\n        actionsForClip = this._actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      return actionsForClip.actionByRoot[rootUuid] || null;\n    }\n\n    return null;\n  },\n  // deactivates all previously scheduled actions\n  stopAllAction: function stopAllAction() {\n    var actions = this._actions,\n        nActions = this._nActiveActions;\n\n    for (var i = nActions - 1; i >= 0; --i) {\n      actions[i].stop();\n    }\n\n    return this;\n  },\n  // advance the time and update apply the animation\n  update: function update(deltaTime) {\n    deltaTime *= this.timeScale;\n    var actions = this._actions,\n        nActions = this._nActiveActions,\n        time = this.time += deltaTime,\n        timeDirection = Math.sign(deltaTime),\n        accuIndex = this._accuIndex ^= 1; // run active actions\n\n    for (var i = 0; i !== nActions; ++i) {\n      var action = actions[i];\n\n      action._update(time, deltaTime, timeDirection, accuIndex);\n    } // update scene graph\n\n\n    var bindings = this._bindings,\n        nBindings = this._nActiveBindings;\n\n    for (var _i = 0; _i !== nBindings; ++_i) {\n      bindings[_i].apply(accuIndex);\n    }\n\n    return this;\n  },\n  // Allows you to seek to a specific time in an animation.\n  setTime: function setTime(timeInSeconds) {\n    this.time = 0; // Zero out time attribute for AnimationMixer object;\n\n    for (var i = 0; i < this._actions.length; i++) {\n      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n    }\n\n    return this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n  },\n  // return this mixer's root target object\n  getRoot: function getRoot() {\n    return this._root;\n  },\n  // free all resources specific to a particular clip\n  uncacheClip: function uncacheClip(clip) {\n    var actions = this._actions,\n        clipUuid = clip.uuid,\n        actionsByClip = this._actionsByClip,\n        actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      // note: just calling _removeInactiveAction would mess up the\n      // iteration state and also require updating the state we can\n      // just throw away\n      var actionsToRemove = actionsForClip.knownActions;\n\n      for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {\n        var action = actionsToRemove[i];\n\n        this._deactivateAction(action);\n\n        var cacheIndex = action._cacheIndex,\n            lastInactiveAction = actions[actions.length - 1];\n        action._cacheIndex = null;\n        action._byClipCacheIndex = null;\n        lastInactiveAction._cacheIndex = cacheIndex;\n        actions[cacheIndex] = lastInactiveAction;\n        actions.pop();\n\n        this._removeInactiveBindingsForAction(action);\n      }\n\n      delete actionsByClip[clipUuid];\n    }\n  },\n  // free all resources specific to a particular root target object\n  uncacheRoot: function uncacheRoot(root) {\n    var rootUuid = root.uuid,\n        actionsByClip = this._actionsByClip;\n\n    for (var clipUuid in actionsByClip) {\n      var actionByRoot = actionsByClip[clipUuid].actionByRoot,\n          action = actionByRoot[rootUuid];\n\n      if (action !== undefined) {\n        this._deactivateAction(action);\n\n        this._removeInactiveAction(action);\n      }\n    }\n\n    var bindingsByRoot = this._bindingsByRootAndName,\n        bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName !== undefined) {\n      for (var trackName in bindingByName) {\n        var binding = bindingByName[trackName];\n        binding.restoreOriginalState();\n\n        this._removeInactiveBinding(binding);\n      }\n    }\n  },\n  // remove a targeted clip from the cache\n  uncacheAction: function uncacheAction(clip, optionalRoot) {\n    var action = this.existingAction(clip, optionalRoot);\n\n    if (action !== null) {\n      this._deactivateAction(action);\n\n      this._removeInactiveAction(action);\n    }\n  }\n});\nexport { AnimationMixer };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/animation/AnimationMixer.js"],"names":["AnimationAction","EventDispatcher","LinearInterpolant","PropertyBinding","PropertyMixer","AnimationClip","NormalAnimationBlendMode","AnimationMixer","root","_root","_initMemoryManager","_accuIndex","time","timeScale","prototype","Object","assign","create","constructor","_bindAction","action","prototypeAction","_localRoot","tracks","_clip","nTracks","length","bindings","_propertyBindings","interpolants","_interpolants","rootUuid","uuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","undefined","i","track","trackName","name","binding","_cacheIndex","referenceCount","_addInactiveBinding","path","parsedPath","ValueTypeName","getValueSize","resultBuffer","buffer","_activateAction","_isActiveAction","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","n","useCount","_lendBinding","saveOriginalState","_lendAction","_deactivateAction","restoreOriginalState","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_bindings","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","scope","stats","actions","total","inUse","controlInterpolants","index","actionsByClip","actionByRoot","_byClipCacheIndex","push","_removeInactiveAction","lastInactiveAction","cacheIndex","pop","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","rootNode","lastInactiveBinding","keys","firstInactiveBinding","lastActiveBinding","_lendControlInterpolant","interpolant","Float32Array","_controlInterpolantsResultBuffer","__cacheIndex","_takeBackControlInterpolant","lastActiveInterpolant","clipAction","clip","optionalRoot","blendMode","clipObject","findByName","existingAction","newAction","stopAllAction","nActions","stop","update","deltaTime","timeDirection","Math","sign","accuIndex","_update","nBindings","apply","setTime","timeInSeconds","getRoot","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction"],"mappings":"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","sourcesContent":["import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nfunction AnimationMixer( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n}\n\nAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: AnimationMixer,\n\n\t_bindAction: function ( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function ( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function ( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function () {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction: function ( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function ( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function ( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function ( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function ( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function ( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function ( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function ( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function () {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function ( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function ( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function ( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function () {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function ( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime: function ( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function () {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function ( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function ( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function ( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { AnimationMixer };\n"]},"metadata":{},"sourceType":"module"}