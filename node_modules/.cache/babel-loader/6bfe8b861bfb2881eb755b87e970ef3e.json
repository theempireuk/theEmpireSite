{"ast":null,"code":"import { ZeroCurvatureEnding } from '../../constants.js';\nimport { Interpolant } from '../Interpolant.js';\nimport { WrapAroundEnding, ZeroSlopeEnding } from '../../constants.js';\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nfunction CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  this._weightPrev = -0;\n  this._offsetPrev = -0;\n  this._weightNext = -0;\n  this._offsetNext = -0;\n}\n\nCubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {\n  constructor: CubicInterpolant,\n  DefaultSettings_: {\n    endingStart: ZeroCurvatureEnding,\n    endingEnd: ZeroCurvatureEnding\n  },\n  intervalChanged_: function intervalChanged_(i1, t0, t1) {\n    var pp = this.parameterPositions;\n    var iPrev = i1 - 2,\n        iNext = i1 + 1,\n        tPrev = pp[iPrev],\n        tNext = pp[iNext];\n\n    if (tPrev === undefined) {\n      switch (this.getSettings_().endingStart) {\n        case ZeroSlopeEnding:\n          // f'(t0) = 0\n          iPrev = i1;\n          tPrev = 2 * t0 - t1;\n          break;\n\n        case WrapAroundEnding:\n          // use the other end of the curve\n          iPrev = pp.length - 2;\n          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];\n          break;\n\n        default:\n          // ZeroCurvatureEnding\n          // f''(t0) = 0 a.k.a. Natural Spline\n          iPrev = i1;\n          tPrev = t1;\n      }\n    }\n\n    if (tNext === undefined) {\n      switch (this.getSettings_().endingEnd) {\n        case ZeroSlopeEnding:\n          // f'(tN) = 0\n          iNext = i1;\n          tNext = 2 * t1 - t0;\n          break;\n\n        case WrapAroundEnding:\n          // use the other end of the curve\n          iNext = 1;\n          tNext = t1 + pp[1] - pp[0];\n          break;\n\n        default:\n          // ZeroCurvatureEnding\n          // f''(tN) = 0, a.k.a. Natural Spline\n          iNext = i1 - 1;\n          tNext = t0;\n      }\n    }\n\n    var halfDt = (t1 - t0) * 0.5,\n        stride = this.valueSize;\n    this._weightPrev = halfDt / (t0 - tPrev);\n    this._weightNext = halfDt / (tNext - t1);\n    this._offsetPrev = iPrev * stride;\n    this._offsetNext = iNext * stride;\n  },\n  interpolate_: function interpolate_(i1, t0, t, t1) {\n    var result = this.resultBuffer,\n        values = this.sampleValues,\n        stride = this.valueSize,\n        o1 = i1 * stride,\n        o0 = o1 - stride,\n        oP = this._offsetPrev,\n        oN = this._offsetNext,\n        wP = this._weightPrev,\n        wN = this._weightNext,\n        p = (t - t0) / (t1 - t0),\n        pp = p * p,\n        ppp = pp * p; // evaluate polynomials\n\n    var sP = -wP * ppp + 2 * wP * pp - wP * p;\n    var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    var sN = wN * ppp - wN * pp; // combine data linearly\n\n    for (var i = 0; i !== stride; ++i) {\n      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];\n    }\n\n    return result;\n  }\n});\nexport { CubicInterpolant };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/math/interpolants/CubicInterpolant.js"],"names":["ZeroCurvatureEnding","Interpolant","WrapAroundEnding","ZeroSlopeEnding","CubicInterpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","call","_weightPrev","_offsetPrev","_weightNext","_offsetNext","prototype","Object","assign","create","constructor","DefaultSettings_","endingStart","endingEnd","intervalChanged_","i1","t0","t1","pp","iPrev","iNext","tPrev","tNext","undefined","getSettings_","length","halfDt","stride","valueSize","interpolate_","t","result","values","o1","o0","oP","oN","wP","wN","p","ppp","sP","s0","s1","sN","i"],"mappings":"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","sourcesContent":["import { ZeroCurvatureEnding } from '../../constants.js';\nimport { Interpolant } from '../Interpolant.js';\nimport { WrapAroundEnding, ZeroSlopeEnding } from '../../constants.js';\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = - 0;\n\tthis._offsetPrev = - 0;\n\tthis._weightNext = - 0;\n\tthis._offsetNext = - 0;\n\n}\n\nCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: ZeroCurvatureEnding,\n\t\tendingEnd: ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function ( i1, t0, t1 ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet iPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n\nexport { CubicInterpolant };\n"]},"metadata":{},"sourceType":"module"}