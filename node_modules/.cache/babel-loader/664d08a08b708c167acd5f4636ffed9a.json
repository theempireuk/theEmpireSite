{"ast":null,"code":"import { EventDispatcher } from '../core/EventDispatcher.js';\nimport { MirroredRepeatWrapping, ClampToEdgeWrapping, RepeatWrapping, LinearEncoding, UnsignedByteType, RGBAFormat, LinearMipmapLinearFilter, LinearFilter, UVMapping } from '../constants.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { ImageUtils } from '../extras/ImageUtils.js';\nvar textureId = 0;\n\nfunction Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {\n  Object.defineProperty(this, 'id', {\n    value: textureId++\n  });\n  this.uuid = MathUtils.generateUUID();\n  this.name = '';\n  this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n  this.mipmaps = [];\n  this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n  this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n  this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n  this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;\n  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n  this.format = format !== undefined ? format : RGBAFormat;\n  this.internalFormat = null;\n  this.type = type !== undefined ? type : UnsignedByteType;\n  this.offset = new Vector2(0, 0);\n  this.repeat = new Vector2(1, 1);\n  this.center = new Vector2(0, 0);\n  this.rotation = 0;\n  this.matrixAutoUpdate = true;\n  this.matrix = new Matrix3();\n  this.generateMipmaps = true;\n  this.premultiplyAlpha = false;\n  this.flipY = true;\n  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n  //\n  // Also changing the encoding after already used by a Material will not automatically make the Material\n  // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\n  this.encoding = encoding !== undefined ? encoding : LinearEncoding;\n  this.version = 0;\n  this.onUpdate = null;\n}\n\nTexture.DEFAULT_IMAGE = undefined;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n  constructor: Texture,\n  isTexture: true,\n  updateMatrix: function updateMatrix() {\n    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(source) {\n    this.name = source.name;\n    this.image = source.image;\n    this.mipmaps = source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n    this.anisotropy = source.anisotropy;\n    this.format = source.format;\n    this.internalFormat = source.internalFormat;\n    this.type = source.type;\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.center.copy(source.center);\n    this.rotation = source.rotation;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrix.copy(source.matrix);\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    this.encoding = source.encoding;\n    return this;\n  },\n  toJSON: function toJSON(meta) {\n    var isRootObject = meta === undefined || typeof meta === 'string';\n\n    if (!isRootObject && meta.textures[this.uuid] !== undefined) {\n      return meta.textures[this.uuid];\n    }\n\n    var output = {\n      metadata: {\n        version: 4.5,\n        type: 'Texture',\n        generator: 'Texture.toJSON'\n      },\n      uuid: this.uuid,\n      name: this.name,\n      mapping: this.mapping,\n      repeat: [this.repeat.x, this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: [this.center.x, this.center.y],\n      rotation: this.rotation,\n      wrap: [this.wrapS, this.wrapT],\n      format: this.format,\n      type: this.type,\n      encoding: this.encoding,\n      minFilter: this.minFilter,\n      magFilter: this.magFilter,\n      anisotropy: this.anisotropy,\n      flipY: this.flipY,\n      premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: this.unpackAlignment\n    };\n\n    if (this.image !== undefined) {\n      // TODO: Move to THREE.Image\n      var image = this.image;\n\n      if (image.uuid === undefined) {\n        image.uuid = MathUtils.generateUUID(); // UGH\n      }\n\n      if (!isRootObject && meta.images[image.uuid] === undefined) {\n        var url;\n\n        if (Array.isArray(image)) {\n          // process array of images e.g. CubeTexture\n          url = [];\n\n          for (var i = 0, l = image.length; i < l; i++) {\n            url.push(ImageUtils.getDataURL(image[i]));\n          }\n        } else {\n          // process single image\n          url = ImageUtils.getDataURL(image);\n        }\n\n        meta.images[image.uuid] = {\n          uuid: image.uuid,\n          url: url\n        };\n      }\n\n      output.image = image.uuid;\n    }\n\n    if (!isRootObject) {\n      meta.textures[this.uuid] = output;\n    }\n\n    return output;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  },\n  transformUv: function transformUv(uv) {\n    if (this.mapping !== UVMapping) return uv;\n    uv.applyMatrix3(this.matrix);\n\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n\n          break;\n      }\n    }\n\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n\n          break;\n      }\n    }\n\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n\n    return uv;\n  }\n});\nObject.defineProperty(Texture.prototype, \"needsUpdate\", {\n  set: function set(value) {\n    if (value === true) this.version++;\n  }\n});\nexport { Texture };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/textures/Texture.js"],"names":["EventDispatcher","MirroredRepeatWrapping","ClampToEdgeWrapping","RepeatWrapping","LinearEncoding","UnsignedByteType","RGBAFormat","LinearMipmapLinearFilter","LinearFilter","UVMapping","MathUtils","Vector2","Matrix3","ImageUtils","textureId","Texture","image","mapping","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","encoding","Object","defineProperty","value","uuid","generateUUID","name","undefined","DEFAULT_IMAGE","mipmaps","DEFAULT_MAPPING","internalFormat","offset","repeat","center","rotation","matrixAutoUpdate","matrix","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","version","onUpdate","prototype","assign","create","constructor","isTexture","updateMatrix","setUvTransform","x","y","clone","copy","source","slice","toJSON","meta","isRootObject","textures","output","metadata","generator","wrap","images","url","Array","isArray","i","l","length","push","getDataURL","dispose","dispatchEvent","transformUv","uv","applyMatrix3","Math","floor","abs","ceil","set"],"mappings":"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","sourcesContent":["import { EventDispatcher } from '../core/EventDispatcher.js';\nimport {\n\tMirroredRepeatWrapping,\n\tClampToEdgeWrapping,\n\tRepeatWrapping,\n\tLinearEncoding,\n\tUnsignedByteType,\n\tRGBAFormat,\n\tLinearMipmapLinearFilter,\n\tLinearFilter,\n\tUVMapping\n} from '../constants.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { ImageUtils } from '../extras/ImageUtils.js';\n\nlet textureId = 0;\n\nfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\n\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : RGBAFormat;\n\tthis.internalFormat = null;\n\tthis.type = type !== undefined ? type : UnsignedByteType;\n\n\tthis.offset = new Vector2( 0, 0 );\n\tthis.repeat = new Vector2( 1, 1 );\n\tthis.center = new Vector2( 0, 0 );\n\tthis.rotation = 0;\n\n\tthis.matrixAutoUpdate = true;\n\tthis.matrix = new Matrix3();\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t//\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\n\n\tthis.version = 0;\n\tthis.onUpdate = null;\n\n}\n\nTexture.DEFAULT_IMAGE = undefined;\nTexture.DEFAULT_MAPPING = UVMapping;\n\nTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Texture,\n\n\tisTexture: true,\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\ttype: this.type,\n\t\t\tencoding: this.encoding,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tconst image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = MathUtils.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tlet url;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\t// process array of images e.g. CubeTexture\n\n\t\t\t\t\turl = [];\n\n\t\t\t\t\tfor ( let i = 0, l = image.length; i < l; i ++ ) {\n\n\t\t\t\t\t\turl.push( ImageUtils.getDataURL( image[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// process single image\n\n\t\t\t\t\turl = ImageUtils.getDataURL( image );\n\n\t\t\t\t}\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: url\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t},\n\n\ttransformUv: function ( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n} );\n\nObject.defineProperty( Texture.prototype, \"needsUpdate\", {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\n\nexport { Texture };\n"]},"metadata":{},"sourceType":"module"}