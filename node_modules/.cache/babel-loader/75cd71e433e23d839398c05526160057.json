{"ast":null,"code":"import { RGBAFormat, RGBFormat } from '../constants.js';\nimport { ImageLoader } from './ImageLoader.js';\nimport { Texture } from '../textures/Texture.js';\nimport { Loader } from './Loader.js';\n\nfunction TextureLoader(manager) {\n  Loader.call(this, manager);\n}\n\nTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: TextureLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var texture = new Texture();\n    var loader = new ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n    loader.load(url, function (image) {\n      texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\n      var isJPEG = url.search(/\\.jpe?g($|\\?)/i) > 0 || url.search(/^data\\:image\\/jpeg/) === 0;\n      texture.format = isJPEG ? RGBFormat : RGBAFormat;\n      texture.needsUpdate = true;\n\n      if (onLoad !== undefined) {\n        onLoad(texture);\n      }\n    }, onProgress, onError);\n    return texture;\n  }\n});\nexport { TextureLoader };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/loaders/TextureLoader.js"],"names":["RGBAFormat","RGBFormat","ImageLoader","Texture","Loader","TextureLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","texture","loader","setCrossOrigin","crossOrigin","setPath","path","image","isJPEG","search","format","needsUpdate","undefined"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,SAArB,QAAsC,iBAAtC;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,MAAT,QAAuB,aAAvB;;AAEA,SAASC,aAAT,CAAwBC,OAAxB,EAAkC;AAEjCF,EAAAA,MAAM,CAACG,IAAP,CAAa,IAAb,EAAmBD,OAAnB;AAEA;;AAEDD,aAAa,CAACG,SAAd,GAA0BC,MAAM,CAACC,MAAP,CAAeD,MAAM,CAACE,MAAP,CAAeP,MAAM,CAACI,SAAtB,CAAf,EAAkD;AAE3EI,EAAAA,WAAW,EAAEP,aAF8D;AAI3EQ,EAAAA,IAAI,EAAE,cAAWC,GAAX,EAAgBC,MAAhB,EAAwBC,UAAxB,EAAoCC,OAApC,EAA8C;AAEnD,QAAMC,OAAO,GAAG,IAAIf,OAAJ,EAAhB;AAEA,QAAMgB,MAAM,GAAG,IAAIjB,WAAJ,CAAiB,KAAKI,OAAtB,CAAf;AACAa,IAAAA,MAAM,CAACC,cAAP,CAAuB,KAAKC,WAA5B;AACAF,IAAAA,MAAM,CAACG,OAAP,CAAgB,KAAKC,IAArB;AAEAJ,IAAAA,MAAM,CAACN,IAAP,CAAaC,GAAb,EAAkB,UAAWU,KAAX,EAAmB;AAEpCN,MAAAA,OAAO,CAACM,KAAR,GAAgBA,KAAhB,CAFoC,CAIpC;;AACA,UAAMC,MAAM,GAAGX,GAAG,CAACY,MAAJ,CAAY,gBAAZ,IAAiC,CAAjC,IAAsCZ,GAAG,CAACY,MAAJ,CAAY,oBAAZ,MAAuC,CAA5F;AAEAR,MAAAA,OAAO,CAACS,MAAR,GAAiBF,MAAM,GAAGxB,SAAH,GAAeD,UAAtC;AACAkB,MAAAA,OAAO,CAACU,WAAR,GAAsB,IAAtB;;AAEA,UAAKb,MAAM,KAAKc,SAAhB,EAA4B;AAE3Bd,QAAAA,MAAM,CAAEG,OAAF,CAAN;AAEA;AAED,KAhBD,EAgBGF,UAhBH,EAgBeC,OAhBf;AAkBA,WAAOC,OAAP;AAEA;AAhC0E,CAAlD,CAA1B;AAqCA,SAASb,aAAT","sourcesContent":["import { RGBAFormat, RGBFormat } from '../constants.js';\nimport { ImageLoader } from './ImageLoader.js';\nimport { Texture } from '../textures/Texture.js';\nimport { Loader } from './Loader.js';\n\nfunction TextureLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: TextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\n\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\tconst isJPEG = url.search( /\\.jpe?g($|\\?)/i ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n\nexport { TextureLoader };\n"]},"metadata":{},"sourceType":"module"}