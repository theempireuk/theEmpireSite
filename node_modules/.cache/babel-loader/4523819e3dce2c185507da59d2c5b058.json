{"ast":null,"code":"import { Ray } from '../math/Ray.js';\nimport { Layers } from './Layers.js';\n\nfunction Raycaster(origin, direction, near, far) {\n  this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)\n\n  this.near = near || 0;\n  this.far = far || Infinity;\n  this.camera = null;\n  this.layers = new Layers();\n  this.params = {\n    Mesh: {},\n    Line: {\n      threshold: 1\n    },\n    LOD: {},\n    Points: {\n      threshold: 1\n    },\n    Sprite: {}\n  };\n  Object.defineProperties(this.params, {\n    PointCloud: {\n      get: function get() {\n        console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');\n        return this.Points;\n      }\n    }\n  });\n}\n\nfunction ascSort(a, b) {\n  return a.distance - b.distance;\n}\n\nfunction _intersectObject(object, raycaster, intersects, recursive) {\n  if (object.layers.test(raycaster.layers)) {\n    object.raycast(raycaster, intersects);\n  }\n\n  if (recursive === true) {\n    var children = object.children;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      _intersectObject(children[i], raycaster, intersects, true);\n    }\n  }\n}\n\nObject.assign(Raycaster.prototype, {\n  set: function set(origin, direction) {\n    // direction is assumed to be normalized (for accurate distance calculations)\n    this.ray.set(origin, direction);\n  },\n  setFromCamera: function setFromCamera(coords, camera) {\n    if (camera && camera.isPerspectiveCamera) {\n      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n      this.camera = camera;\n    } else if (camera && camera.isOrthographicCamera) {\n      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera\n\n      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n      this.camera = camera;\n    } else {\n      console.error('THREE.Raycaster: Unsupported camera type.');\n    }\n  },\n  intersectObject: function intersectObject(object, recursive, optionalTarget) {\n    var intersects = optionalTarget || [];\n\n    _intersectObject(object, this, intersects, recursive);\n\n    intersects.sort(ascSort);\n    return intersects;\n  },\n  intersectObjects: function intersectObjects(objects, recursive, optionalTarget) {\n    var intersects = optionalTarget || [];\n\n    if (Array.isArray(objects) === false) {\n      console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');\n      return intersects;\n    }\n\n    for (var i = 0, l = objects.length; i < l; i++) {\n      _intersectObject(objects[i], this, intersects, recursive);\n    }\n\n    intersects.sort(ascSort);\n    return intersects;\n  }\n});\nexport { Raycaster };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/core/Raycaster.js"],"names":["Ray","Layers","Raycaster","origin","direction","near","far","ray","Infinity","camera","layers","params","Mesh","Line","threshold","LOD","Points","Sprite","Object","defineProperties","PointCloud","get","console","warn","ascSort","a","b","distance","intersectObject","object","raycaster","intersects","recursive","test","raycast","children","i","l","length","assign","prototype","set","setFromCamera","coords","isPerspectiveCamera","setFromMatrixPosition","matrixWorld","x","y","unproject","sub","normalize","isOrthographicCamera","transformDirection","error","optionalTarget","sort","intersectObjects","objects","Array","isArray"],"mappings":"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","sourcesContent":["import { Ray } from '../math/Ray.js';\nimport { Layers } from './Layers.js';\n\nfunction Raycaster( origin, direction, near, far ) {\n\n\tthis.ray = new Ray( origin, direction );\n\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\tthis.near = near || 0;\n\tthis.far = far || Infinity;\n\tthis.camera = null;\n\tthis.layers = new Layers();\n\n\tthis.params = {\n\t\tMesh: {},\n\t\tLine: { threshold: 1 },\n\t\tLOD: {},\n\t\tPoints: { threshold: 1 },\n\t\tSprite: {}\n\t};\n\n\tObject.defineProperties( this.params, {\n\t\tPointCloud: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\treturn this.Points;\n\n\t\t\t}\n\t\t}\n\t} );\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t}\n\n\tif ( recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\nObject.assign( Raycaster.prototype, {\n\n\tset: function ( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t},\n\n\tsetFromCamera: function ( coords, camera ) {\n\n\t\tif ( ( camera && camera.isPerspectiveCamera ) ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t}\n\n\t},\n\n\tintersectObject: function ( object, recursive, optionalTarget ) {\n\n\t\tconst intersects = optionalTarget || [];\n\n\t\tintersectObject( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t},\n\n\tintersectObjects: function ( objects, recursive, optionalTarget ) {\n\n\t\tconst intersects = optionalTarget || [];\n\n\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\treturn intersects;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n} );\n\n\nexport { Raycaster };\n"]},"metadata":{},"sourceType":"module"}